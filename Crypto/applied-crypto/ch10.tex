\chapter{Notes on Ch. 10}

\textbf{Topic:} Introduce tools use used in public-key cryptography, digital signatures, and key exchange.\\
\vspace{1em}

To begin let us start with a toy problem: Generating a 
shared secret key between two parties, so that a passive eavesdropping adversary cannot guess the shared key. The adversary only has the ability to lisen, not to generate or alter messages that are sent. 

Let us define a key exchange protocol \(P\) as a pair of probalstic machines \(A,B\)  where each take turns sending messages to each other. At the end of the communication period a key \(k\)  is obtained that is the same between the two. 

A protocol transcript \(T_P\) is the sequence of messages sent between \(A,B\) during a single execution of \(P\). Note \(A,B\) are probalistic machines and thus a different transcript is obtained each time. In terms of the adversary, it is important to note that the adversary \(\mathcal{A}\) also obtains \(T_P\) and thus in the case of security againsts an eavesdropper, our adversary can interpret these messages, but it should not be able to gain information about \(k\) from this transcript. 

A briefly more formal definition of \(T_P\) as a random variable whose a function of the random bits generated by \(A,B\). We again note that our adversary sees this entire transcript with the goal of obtaining the secret key \(k\). 

\begin{attackGame}( Anonymous key exchange)
For a key exchange \(P=(A,B)\) and a adversary \(\mathcal{A}\) the attack game runs as followed:
\begin{enumerate}
    \item The protocol is ran between \(A\) and \(B\) to generate a shared private key \(k\) and a transcript \(T_P\) which is also obtained by \(\mathcal{A}\). 
    \item \(\mathcal{A}\) outputs a guess \(\hat{k}\) for \(k\)       
\end{enumerate}

We define \(\adv\) or \(AnonKEadv[\adv, P]\) as the probability that \(\hat{k} = k\). 
\end{attackGame}

\begin{definition}
    A anonymous key exchange protocol \(P\) is known to be secure against an eavesdropper if for all efficient (polynomial times ) adversaries \(\adv\) their advantage is negligible. 
\end{definition}

\begin{remark}
Why is this a weak form of security? 
\begin{enumerate}
    \item Assume the adversary is unable to tamper with the message 
    \item We assume that \(\adv\) cannot guess the entire bit of \(k\) not that it might not learn some information about it. 
    \item The protocol does not guarantee the identity of either \(A\) or \(B\).   
\end{enumerate}
\end{remark}

\section{One-Way Trapdoor Functions}

We define a one way function as a function \(F: X \to Y\) that is easy to compute but hard to convert.  A trapdoor is a secret that allows one to efficiently invert the function, but if one does not know this secret the function is hard to invert.  

\begin{definition}(Trapdoor function scheme)
    Let \(X\) and \(Y\) be finite sets, We then define a trapdoor function scheme \(T\) as defined over \((X,Y)\)  as a triple of algorithms \((G,F,I)\) where: 
    \begin{itemize}
        \item G is a probalistic key generation algorithm that is invoked as \((pk, sk) \gets G()\) where \(pk\) is referred to the public key and \(sk\) as the secret key 
        \item F is a deterministic algorithm that is invoked as \(y \gets F(pk, x)\) where again \(pk\) is the public key and \(x \in X\). The output \(y \in Y\). 
        \item I is a deterministic algorithm that is invoked as \(x \gets I(sk, y)\) where \(sk\) is the secret key and \(y \in Y\). We say that \(x \in X\). 
        
    \end{itemize}
    Lastly, for all outputs \(pk, sk\) of \(G()\) and for all \(x \in X\) we have that \(I(sk, F(pk, x)) = x\).  
\end{definition}

We note that this last property ensures that \(F(pk, \dot )\) is an injective function.  Moreover, when \(X=Y\) this function is then also surjective, as it is merely a permutation on the set. Due to this, when \(X=Y\) we refer to this as a trapdoor permutation scheme. 

\begin{attackGame} (One way trapdoor function scheme)
    \begin{itemize}
    \item The challenger computes 
    \[
        (pk, sk) \gets G(), x \sample X, y \gets F(pk, x)
    \] 
    \item The adversary outputs \(\hat{x} \in X\)
 
    \end{itemize}
    The adversary's advantage in inverting \(T\) denoted \(OWadv[\adv, T]\) is the probability that \(\hat{x} = x\)    
\end{attackGame}

\begin{definition}
    A trapdoor function scheme \(T\) is one way if for all efficient (polynomial time ) adversaries \(\adv\), their advantage is negligible.    
\end{definition}

A natural next question in the perspective of key exchange is how could we use trapdoor one way functions for key exchange. We can define a protocol as followed:
\begin{itemize}
    \item Alice computes \((pk, sk) \gets G()\) and sends \(pk\) to bob. 
    \item After receiving \(pk\) bob computes  for some \(x \sample x\), \(y \gets F(pk, x)\) and then sends this \(y\) to alice 
    \item After receiving \(y\) alice computes \(x \gets I(sk, y)\)       
\end{itemize}
In this case we see that the shared secret key is \(x\). 


\section{A trapdoor permutation scheme based on RSA}
  
As of now, RSA (or close alternatives) is one of the only canidates for a trapdoor permutation scheme. 

Let us first briefly recall a probalistic algorithm RSAgen, given some \(l > 2\) and odd integer \(e > 2\) 

We say that \(RSAGen(l, e) = \)
\begin{itemize}
    \item generate a random \(l\)-bit prime \(p\) such that \(gcd(e, p-1) = 1\) 
    \item generate a random \(l\)-bit prime \(q\) such that \(gcd(e, q-1) = 1 \) and \(q \neq p\)
    \item \( n \gets pq\)
    \item \( d \gets e^{-1} \mod (p-1)(q-1)\)
          
\end{itemize}
output (n,d)

Given \(RSAGen\) we can now define our RSA trapdoor permutation scheme \(T_{RSA} = (G,F,I)\) which is parameterized by fixed values \(l, e\). 

\begin{itemize}
\item We see that key generation follows as \(G() \coloneqq  (n,d) \sample RSAGen(l, e), pk \gets (n,e) sk \gets (n,d) \) 
\item For a given public key \(pk = (n,e)\) and \(x \in \Z_n\) we define \(F(pk, x ) \coloneqq x^e \in \Z_n\)
\item For a given secret key  \(sk = (n,d)\) and \(y \in \Z_n\) we define \(I(sk, y) \coloneqq  y^d \in \Z_n\)   
\end{itemize}


\begin{theorem}
    Let \(n=pq\) where \(p\) and \(q\) are distinct primes. Let \(e \) and \(d\) be integers such that \(ed \equiv 1 (\mod (p-1)(q-1))\). Then for all \(x \in \Z\) we have \(x^{ed} \equiv x (\mod n)\).        
\end{theorem}

It is important to note that factoring \(n\) is believed to be hard, provided that \(l\) is sufficently large. This generally means we chose \(l\) to be \(1000\) to \(1500\).  Additionaly, the only known algorithm to invert \(T_{RSA}\) is to first factor \(n\) and then compute \(d\). Note that this has not been proved but based on current evidence it is belied that \(T_{RSA}\) is one way.          

\begin{attackGame} (RSA)
    For a given integers \(l > 2\) and odd integers \(e > 2\) and an adversary \(\adv\), an attack game goes as: 
    \begin{itemize}
        \item Challenger and adversary take \((l,e)\) as in put.
        \item Challengers compute \((n,d) \sample RSAGEN(l,e), x \sample \Z_n, y \gets x^e \in \Z_n\) and sends \((n,y)\) to the adversary. 
        \item Adversary outputs \(\hat{x} \in \Z_n\)     
    \end{itemize}
    THe adversary advantage in breaking RSA is the probability that \(\hat{x} = x\). 
\end{attackGame}

Note \(n\) is often called the RSA modulus, \(e\) the encryption exponent, \(d\) the decryption exponent, \((n,y)\) an instance of the RSA problem, and \(x\) a solution to the problem.     

Given RSA as defined above let us now consider key exchange utilizing RSA:

The protocol runs as followed: 
\begin{enumerate}
    \item Alice computes \((n,d) \sample RSAGEN(l, e) \) and sends \((n,e)\) to bob. 
    \item Bob computes \(x \sample Z_n, y \gets x^e\)and sends \(y\) to alice. 
    \item Given \(y\), Alice computes \(x \gets y^d\)      
\end{enumerate}
    The secret shared by Alice and Bob is \(x\). 

\section{Diffie-Hellman Key Exchange}

Let us outline a protocol for key exchange utilizing Diffie-hellman security notations:

First we assume we have some group \(\G\) as well as a generator \(g\) within it, whose order is \(q\) that was generated once for the entire system setup.  
\begin{enumerate}
    \item Alice compute \(\alpha  \sample Z_q\), \(u \gets g^\alpha \) and sends \(u\) to Bob. 
    \item Bob computes  \(\beta \sample \Z_q\) and sends \(v \gets g^\beta \) to Alice. 
    \item Alice computes now \(w \gets v^\alpha \)
    \item Bob computes now \(w \gets u^\beta \)      
\end{enumerate}
We see that \(w = v^\alpha  = g^{\alpha \beta }= u^\beta \) 

We note that the discrete logarithm is not enough enough to ensure that this is hard, instead it must hold that given \(g^\alpha , g^\beta \in \G\) where \(\alpha ,\beta  \in \Z_q\)  it hard to compute \(g^{\alpha \beta } \in \G\) . This is known as computational Diffie-Hellman assumption.

\begin{attackGame} (Discrete Logarithm)
 Let \(\G\) be a cyclic group of prime order \(q\) generated by \(g \in G\). For an adversary \(\adv\) the attack game is as followed: 
 \begin{enumerate}
    \item The challenger and the adversary \(\adv\) takes \(\G\) as input. This includes the order \(q\) and the generator \(g \in \G\). 
    \item Challenges compute \(\alpha  \sample \Z_q u \gets g^\alpha \) and sends \(u \in \G\) to the adversary. 
    \item The adversary outputs \(\hat{\alpha } \in \Z_q\)         
 \end{enumerate}
 \(\adv\) advantage in solving the discrete logarithm problem for \(\G\) is the probability that \(\hat{\alpha } = \alpha \).      
\end{attackGame}

\begin{attackGame} (Computational Diffie-Hellman)
    Let \(\G\) be a cyclic group of prime order \(q\) generated by a generator \(g \in \G\). For a given adversary \(\adv\) the attack game is as followed. 
    \begin{enumerate}
        \item  The challenger and adversary take \(\G\) as input along with \(q\) and the generate \(g \in \G\). 
        \item The challenger computes \(\alpha  \sample \Z_q\), \(u \in g^\alpha \), \(v \in g^\beta , w \gets g^{\alpha \beta }\). 
        and sends the pair \((u,v)\) to the adversary. 
        \item The adversary outputs \(\hat{w} \in \G\).         
    \end{enumerate}
    The advantage of the adversary in solving the computational diffie-hellman problem for \(\G\) is the probability that \(\hat{w} = w\).  
\end{attackGame}

\begin{attackGame} (Decisional Diffie-Hellman)
    Let \(\G\) by a cyclic group of prime order \(q\) with a generator \(g \in \G\) and for an adversary \(\adv\) let us define an attack game as following: 
    \begin{enumerate}
        \item Challenger and adversary takes \(\G\) as input along with the generator \(g\) and order \(q\). 
        \item Challenger compute \(\alpha \beta \gamma \sample \Z_q\), \(u \gets g^\alpha , v \gets g^\beta , w_0 \gets g^{\alpha \beta }, w_1 \gets g^\gamma  \)     
        \item The adversary outputs a bit \(b \in \{0,1\}\) 
    \end{enumerate}
    Therefore for the event that the adversary choses their advantage is the difference between this and \(w_0\) or \(w_1\).  
\end{attackGame}

Note that one important property of the discrete log function for a group \( \G\) is that it is either hard almost everywhere or almost nowhere. A middle ground where it is easy for some and not for others is NOT possible. This is due to a property called random self-reduction which can be shown to be true for the discrete log function. 

\begin{theorem}
    Consider a specific cyclic group \(\G\) of prime order \(q\) generated by \(g \in \G\). Suppose that \(\adv\) is a efficient algorithm with the property that if \(u \in \G\) is chosen at random then \(\Pr[\adv(u) = Dlog_q(u) = \epsilon ]\) where the probability is over the random choice of \(u\) and the random chocies made by \(\adv\). Then there is an efficient algorithm B, such that for all \( u \in \G\), \(B\) eithers outputs fail  or \(Dlog(u)\)  and it output the latter with probability \(e\) but now is only over the random choices of \(B\).          
\end{theorem}

Note for a problem with a random self-reduction, if it is hard in the worst case then it is hard on average an important and desirable property for a cryptosystem. 

\section{Attacks on the anonymous Diffie-hellman protocol}. 

An attack known as the man in the middle attack works against any key exchange protocol that does not include some form of authentication for its users. It works as followed: 
\begin{itemize}
    \item Alice sends \((g, g^\alpha )\) to Bob.  The attack blocks this message from reaching bob, He picks a random \(\alpha^\prime \sample \Z_n\) and sends \((g, g^{\alpha^\prime })\) to Bob instead. 
    \item Bob responds with \(g^\beta \). The attack again blocks this message from reaching alice, picks a random \(\beta^\prime  \sample \Z_n \)  and send \(g^{\beta^\prime }\) to alice. 
    \item Now Alice computes key \(k_A \coloneqq g^{\alpha \beta^\prime }\)  and bob computes \(k_B \coloneqq g^{\alpha^\prime \beta }\). The attack knows both \(k_A\) and \(k_B\).   
\end{itemize}
Both parties think they shared the key with each other but infact the attack is the only one that knows both keys, as long as the attack continues this attack of blocking messages, it is possible for them to stay undetected allowing communication between bob and alice without them realizing there is a middle man who is interpreting and possibly editing their messages.

\section{Accumulators}

One such way Alice could commit to an order tuple of elements \(x_1, \ldots x_n \) and later prove to bob that she knows one value \(x_i\) at position \(i\)  in this set is via a merkle tree. Where each proof can be done as a sequence of \(\log_2 n\) hashes. 
Another way to do this is via an accumulator. This allows alice to commit to an unorder set \(S= \{x_1, \ldots  x_n \} \subseteq X \) so that she can later prove to Bob that a particular \(x \in X\) is either in the set \(S\) or not. We call this commitment scheme for unordered sets that allow us to tell if a element is part of a set or not a accumulator.  Moreover, a dynamic accumulator is one where we can add elements to the set \(S\). Therefore  there is some algorithm that takes as input a commitment to a set \(S\) along with an element not in \(S\) and outputs a commitment to a new set \(S^\prime \) which is the union of the two. 

To create a simple dynamic accumulator we use groups of unknown order or (GUO). GUO is a pair \((\G, g)\) where \(\G\) is a description of an abelian group and \(g\) is an element of \(g\) where the size of \(\G\) is difficult to deduce from the pair.  These can be generated by probabilistic group generation algorithm called \(GGen\) that when invokes outputs a pair \((\G, g)\). 

In terms of GGen, we say it satisfies strong RSA assumption, where the game for an adversary \(\adv\) is described as followed. We fun \((\G, g) \sample GGen()\) and send \((\G, g)\) to \(\adv\).  \(\adv\) outputs \((x,e)\) and wins the game if \(x^e =g\) and \(e \neq p_{m+1}\). We say that GGen satisfies the strong RSA assumption if no efficient adversary can win the strong RSA game with respect to GGen with non-neglible advantage. 

There are a number of candidates for GUO where the strong RSA assumption is  believed to hold. One such is the group \(\Z_n^{\star}\) of integers modulo \(n= pq\) where \( n \gets RSAGEN(l, e)\) for some \(, e\). 

Given we have some GUO \((\G, g)\) that is already known for all parties, let us show a construction for an accumulator. We treat \((\G, g)\) as public parameters, additionally we need a collision resistant hash function \(H: X \to Primes(L) \) where Primes(L) is the set of the smallest \(L\) primes. We need that \(L\) to be sufficiently large so that \(H\) can be collision resistant. 

A GUO accumulator works as follows: 

\begin{itemize}
    \item Alice commits to an unorder set \(S = \{x_1, \ldots  x_n\} \in X \) where \(C(S) \coloneqq e_i \gets H(x_i)\) and \(E \gets e_1 \cdot \ldots \cdot e_n \in \Z_n \) we then output \(c = g^E\). 
    \item A membership proof for \(x \in X\) with respect to \(c\). Alice has \((S,x)\), Bob has \((c,x)\) and Alice wants to convince Bob that \(x \) is in \(S\). If \(x \in S\) then \(\beta =  \frac{E}{H(x)}\) is an integer. Alice can prove to bob that \(x\) is in \(S\) by computing \(b \gets g^\beta  = g^{\frac{E}{H(x)}}\) and outputting the short proof \(\pi_x = b\). Bob verifies the proof \(\pi_x = b\) by checking that \(b^{H(x)} = c\). 
    \item A non membership proof that for \(x \in X\) with respect to \(c\) Alice has \((S,x)\) and bob has \((c,x)\), and alice wants to convince bob that \(x\) is not in \(S\). Therefore we see that \(x \not \in S\) that \(E\) and  \(H(x)\) must be relatively prime. A proof of such could be computed by alice and then verified by bob.                        
\end{itemize}

In terms of the security of a accumulator, we say it is secure if no efficient adversary can simultaneously prove that \(x \in S\) and \( x \not \in S\) for some commited set \(S\) and \(x\). Thus they can not generate a proof of membership and non-membership efficiently . 

One other factor of GUO accumulator proofs over Merkle tree proofs is that they can be aggregated together.